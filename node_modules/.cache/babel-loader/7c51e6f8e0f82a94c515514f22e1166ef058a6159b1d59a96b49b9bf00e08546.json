{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ERC4337EthersSigner = void 0;\nconst properties_1 = require(\"@ethersproject/properties\");\nconst abstract_signer_1 = require(\"@ethersproject/abstract-signer\");\nclass ERC4337EthersSigner extends abstract_signer_1.Signer {\n  // TODO: we have 'erc4337provider', remove shared dependencies or avoid two-way reference\n  constructor(config, originalSigner, erc4337provider, httpRpcClient, smartAccountAPI) {\n    super();\n    this.config = config;\n    this.originalSigner = originalSigner;\n    this.erc4337provider = erc4337provider;\n    this.httpRpcClient = httpRpcClient;\n    this.smartAccountAPI = smartAccountAPI;\n    (0, properties_1.defineReadOnly)(this, 'provider', erc4337provider);\n  }\n  // This one is called by Contract. It signs the request and passes in to Provider to be sent.\n  async sendTransaction(transaction) {\n    var _a, _b, _c;\n    const tx = await this.populateTransaction(transaction);\n    await this.verifyAllNecessaryFields(tx);\n    const userOperation = await this.smartAccountAPI.createSignedUserOp({\n      target: (_a = tx.to) !== null && _a !== void 0 ? _a : '',\n      data: (_c = (_b = tx.data) === null || _b === void 0 ? void 0 : _b.toString()) !== null && _c !== void 0 ? _c : '',\n      value: tx.value,\n      gasLimit: tx.gasLimit\n    });\n    const transactionResponse = await this.erc4337provider.constructUserOpTransactionResponse(userOperation);\n    try {\n      await this.httpRpcClient.sendUserOpToBundler(userOperation);\n    } catch (error) {\n      // console.error('sendUserOpToBundler failed', error)\n      throw this.unwrapError(error);\n    }\n    // TODO: handle errors - transaction that is \"rejected\" by bundler is _not likely_ to ever resolve its \"wait()\"\n    return transactionResponse;\n  }\n  unwrapError(errorIn) {\n    var _a;\n    if (errorIn.body != null) {\n      const errorBody = JSON.parse(errorIn.body);\n      let paymasterInfo = '';\n      let failedOpMessage = (_a = errorBody === null || errorBody === void 0 ? void 0 : errorBody.error) === null || _a === void 0 ? void 0 : _a.message;\n      if ((failedOpMessage === null || failedOpMessage === void 0 ? void 0 : failedOpMessage.includes('FailedOp')) === true) {\n        // TODO: better error extraction methods will be needed\n        const matched = failedOpMessage.match(/FailedOp\\((.*)\\)/);\n        if (matched != null) {\n          const split = matched[1].split(',');\n          paymasterInfo = `(paymaster address: ${split[1]})`;\n          failedOpMessage = split[2];\n        }\n      }\n      const error = new Error(`The bundler has failed to include UserOperation in a batch: ${failedOpMessage} ${paymasterInfo})`);\n      error.stack = errorIn.stack;\n      return error;\n    }\n    return errorIn;\n  }\n  async verifyAllNecessaryFields(transactionRequest) {\n    if (transactionRequest.to == null) {\n      throw new Error('Missing call target');\n    }\n    if (transactionRequest.data == null && transactionRequest.value == null) {\n      // TBD: banning no-op UserOps seems to make sense on provider level\n      throw new Error('Missing call data or value');\n    }\n  }\n  connect(provider) {\n    throw new Error('changing providers is not supported');\n  }\n  async getAddress() {\n    if (this.address == null) {\n      this.address = await this.erc4337provider.getSenderAccountAddress();\n    }\n    return this.address;\n  }\n  async signMessage(message) {\n    return await this.originalSigner.signMessage(message);\n  }\n  async signTransaction(transaction) {\n    throw new Error('not implemented');\n  }\n  async signUserOperation(userOperation) {\n    const message = await this.smartAccountAPI.getUserOpHash(userOperation);\n    return await this.originalSigner.signMessage(message);\n  }\n}\nexports.ERC4337EthersSigner = ERC4337EthersSigner;","map":{"version":3,"names":["properties_1","require","abstract_signer_1","ERC4337EthersSigner","Signer","constructor","config","originalSigner","erc4337provider","httpRpcClient","smartAccountAPI","defineReadOnly","sendTransaction","transaction","tx","populateTransaction","verifyAllNecessaryFields","userOperation","createSignedUserOp","target","_a","to","data","_c","_b","toString","value","gasLimit","transactionResponse","constructUserOpTransactionResponse","sendUserOpToBundler","error","unwrapError","errorIn","body","errorBody","JSON","parse","paymasterInfo","failedOpMessage","message","includes","matched","match","split","Error","stack","transactionRequest","connect","provider","getAddress","address","getSenderAccountAddress","signMessage","signTransaction","signUserOperation","getUserOpHash","exports"],"sources":["../../src/ERC4337EthersSigner.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}