{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BaseAccountAPI = void 0;\nconst ethers_1 = require(\"ethers\");\nconst contracts_1 = require(\"@account-abstraction/contracts\");\nconst utils_1 = require(\"ethers/lib/utils\");\nconst utils_2 = require(\"@account-abstraction/utils\");\nconst calcPreVerificationGas_1 = require(\"./calcPreVerificationGas\");\n/**\n * Base class for all Smart Wallet ERC-4337 Clients to implement.\n * Subclass should inherit 5 methods to support a specific wallet contract:\n *\n * - getAccountInitCode - return the value to put into the \"initCode\" field, if the account is not yet deployed. should create the account instance using a factory contract.\n * - getNonce - return current account's nonce value\n * - encodeExecute - encode the call from entryPoint through our account to the target contract.\n * - signUserOpHash - sign the hash of a UserOp.\n *\n * The user can use the following APIs:\n * - createUnsignedUserOp - given \"target\" and \"calldata\", fill userOp to perform that operation from the account.\n * - createSignedUserOp - helper to call the above createUnsignedUserOp, and then extract the userOpHash and sign it\n */\nclass BaseAccountAPI {\n  /**\n   * base constructor.\n   * subclass SHOULD add parameters that define the owner (signer) of this wallet\n   */\n  constructor(params) {\n    this.isPhantom = true;\n    this.provider = params.provider;\n    this.overheads = params.overheads;\n    this.entryPointAddress = params.entryPointAddress;\n    this.accountAddress = params.accountAddress;\n    this.paymasterAPI = params.paymasterAPI;\n    // factory \"connect\" define the contract address. the contract \"connect\" defines the \"from\" address.\n    this.entryPointView = contracts_1.EntryPoint__factory.connect(params.entryPointAddress, params.provider).connect(ethers_1.ethers.constants.AddressZero);\n  }\n  async init() {\n    if ((await this.provider.getCode(this.entryPointAddress)) === '0x') {\n      throw new Error(`entryPoint not deployed at ${this.entryPointAddress}`);\n    }\n    await this.getAccountAddress();\n    return this;\n  }\n  /**\n   * check if the contract is already deployed.\n   */\n  async checkAccountPhantom() {\n    if (!this.isPhantom) {\n      // already deployed. no need to check anymore.\n      return this.isPhantom;\n    }\n    const senderAddressCode = await this.provider.getCode(this.getAccountAddress());\n    if (senderAddressCode.length > 2) {\n      // console.log(`SimpleAccount Contract already deployed at ${this.senderAddress}`)\n      this.isPhantom = false;\n    } else {\n      // console.log(`SimpleAccount Contract is NOT YET deployed at ${this.senderAddress} - working in \"phantom account\" mode.`)\n    }\n    return this.isPhantom;\n  }\n  /**\n   * calculate the account address even before it is deployed\n   */\n  async getCounterFactualAddress() {\n    const initCode = this.getAccountInitCode();\n    // use entryPoint to query account address (factory can provide a helper method to do the same, but\n    // this method attempts to be generic\n    try {\n      await this.entryPointView.callStatic.getSenderAddress(initCode);\n    } catch (e) {\n      return e.errorArgs.sender;\n    }\n    throw new Error('must handle revert');\n  }\n  /**\n   * return initCode value to into the UserOp.\n   * (either deployment code, or empty hex if contract already deployed)\n   */\n  async getInitCode() {\n    if (await this.checkAccountPhantom()) {\n      return await this.getAccountInitCode();\n    }\n    return '0x';\n  }\n  /**\n   * return maximum gas used for verification.\n   * NOTE: createUnsignedUserOp will add to this value the cost of creation, if the contract is not yet created.\n   */\n  async getVerificationGasLimit() {\n    return 100000;\n  }\n  /**\n   * should cover cost of putting calldata on-chain, and some overhead.\n   * actual overhead depends on the expected bundle size\n   */\n  async getPreVerificationGas(userOp) {\n    const p = await (0, utils_1.resolveProperties)(userOp);\n    return (0, calcPreVerificationGas_1.calcPreVerificationGas)(p, this.overheads);\n  }\n  /**\n   * ABI-encode a user operation. used for calldata cost estimation\n   */\n  packUserOp(userOp) {\n    return (0, utils_2.packUserOp)(userOp, false);\n  }\n  async encodeUserOpCallDataAndGasLimit(detailsForUserOp) {\n    var _a, _b;\n    function parseNumber(a) {\n      if (a == null || a === '') return null;\n      return ethers_1.BigNumber.from(a.toString());\n    }\n    const value = (_a = parseNumber(detailsForUserOp.value)) !== null && _a !== void 0 ? _a : ethers_1.BigNumber.from(0);\n    const callData = await this.encodeExecute(detailsForUserOp.target, value, detailsForUserOp.data);\n    const callGasLimit = (_b = parseNumber(detailsForUserOp.gasLimit)) !== null && _b !== void 0 ? _b : await this.provider.estimateGas({\n      from: this.entryPointAddress,\n      to: this.getAccountAddress(),\n      data: callData\n    });\n    return {\n      callData,\n      callGasLimit\n    };\n  }\n  /**\n   * return userOpHash for signing.\n   * This value matches entryPoint.getUserOpHash (calculated off-chain, to avoid a view call)\n   * @param userOp userOperation, (signature field ignored)\n   */\n  async getUserOpHash(userOp) {\n    const op = await (0, utils_1.resolveProperties)(userOp);\n    const chainId = await this.provider.getNetwork().then(net => net.chainId);\n    return (0, utils_2.getUserOpHash)(op, this.entryPointAddress, chainId);\n  }\n  /**\n   * return the account's address.\n   * this value is valid even before deploying the contract.\n   */\n  async getAccountAddress() {\n    if (this.senderAddress == null) {\n      if (this.accountAddress != null) {\n        this.senderAddress = this.accountAddress;\n      } else {\n        this.senderAddress = await this.getCounterFactualAddress();\n      }\n    }\n    return this.senderAddress;\n  }\n  async estimateCreationGas(initCode) {\n    if (initCode == null || initCode === '0x') return 0;\n    const deployerAddress = initCode.substring(0, 42);\n    const deployerCallData = '0x' + initCode.substring(42);\n    return await this.provider.estimateGas({\n      to: deployerAddress,\n      data: deployerCallData\n    });\n  }\n  /**\n   * create a UserOperation, filling all details (except signature)\n   * - if account is not yet created, add initCode to deploy it.\n   * - if gas or nonce are missing, read them from the chain (note that we can't fill gaslimit before the account is created)\n   * @param info\n   */\n  async createUnsignedUserOp(info) {\n    var _a, _b;\n    const {\n      callData,\n      callGasLimit\n    } = await this.encodeUserOpCallDataAndGasLimit(info);\n    const initCode = await this.getInitCode();\n    const initGas = await this.estimateCreationGas(initCode);\n    const verificationGasLimit = ethers_1.BigNumber.from(await this.getVerificationGasLimit()).add(initGas);\n    let {\n      maxFeePerGas,\n      maxPriorityFeePerGas\n    } = info;\n    if (maxFeePerGas == null || maxPriorityFeePerGas == null) {\n      const feeData = await this.provider.getFeeData();\n      if (maxFeePerGas == null) {\n        maxFeePerGas = (_a = feeData.maxFeePerGas) !== null && _a !== void 0 ? _a : undefined;\n      }\n      if (maxPriorityFeePerGas == null) {\n        maxPriorityFeePerGas = (_b = feeData.maxPriorityFeePerGas) !== null && _b !== void 0 ? _b : undefined;\n      }\n    }\n    const partialUserOp = {\n      sender: this.getAccountAddress(),\n      nonce: this.getNonce(),\n      initCode,\n      callData,\n      callGasLimit,\n      verificationGasLimit,\n      maxFeePerGas,\n      maxPriorityFeePerGas,\n      paymasterAndData: '0x'\n    };\n    let paymasterAndData;\n    if (this.paymasterAPI != null) {\n      // fill (partial) preVerificationGas (all except the cost of the generated paymasterAndData)\n      const userOpForPm = Object.assign(Object.assign({}, partialUserOp), {\n        preVerificationGas: await this.getPreVerificationGas(partialUserOp)\n      });\n      paymasterAndData = await this.paymasterAPI.getPaymasterAndData(userOpForPm);\n    }\n    partialUserOp.paymasterAndData = paymasterAndData !== null && paymasterAndData !== void 0 ? paymasterAndData : '0x';\n    return Object.assign(Object.assign({}, partialUserOp), {\n      preVerificationGas: this.getPreVerificationGas(partialUserOp),\n      signature: ''\n    });\n  }\n  /**\n   * Sign the filled userOp.\n   * @param userOp the UserOperation to sign (with signature field ignored)\n   */\n  async signUserOp(userOp) {\n    const userOpHash = await this.getUserOpHash(userOp);\n    const signature = this.signUserOpHash(userOpHash);\n    return Object.assign(Object.assign({}, userOp), {\n      signature\n    });\n  }\n  /**\n   * helper method: create and sign a user operation.\n   * @param info transaction details for the userOp\n   */\n  async createSignedUserOp(info) {\n    return await this.signUserOp(await this.createUnsignedUserOp(info));\n  }\n  /**\n   * get the transaction that has this userOpHash mined, or null if not found\n   * @param userOpHash returned by sendUserOpToBundler (or by getUserOpHash..)\n   * @param timeout stop waiting after this timeout\n   * @param interval time to wait between polls.\n   * @return the transactionHash this userOp was mined, or null if not found.\n   */\n  async getUserOpReceipt(userOpHash) {\n    let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 30000;\n    let interval = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 5000;\n    const endtime = Date.now() + timeout;\n    while (Date.now() < endtime) {\n      const events = await this.entryPointView.queryFilter(this.entryPointView.filters.UserOperationEvent(userOpHash));\n      if (events.length > 0) {\n        return events[0].transactionHash;\n      }\n      await new Promise(resolve => setTimeout(resolve, interval));\n    }\n    return null;\n  }\n}\nexports.BaseAccountAPI = BaseAccountAPI;","map":{"version":3,"names":["ethers_1","require","contracts_1","utils_1","utils_2","calcPreVerificationGas_1","BaseAccountAPI","constructor","params","isPhantom","provider","overheads","entryPointAddress","accountAddress","paymasterAPI","entryPointView","EntryPoint__factory","connect","ethers","constants","AddressZero","init","getCode","Error","getAccountAddress","checkAccountPhantom","senderAddressCode","length","getCounterFactualAddress","initCode","getAccountInitCode","callStatic","getSenderAddress","e","errorArgs","sender","getInitCode","getVerificationGasLimit","getPreVerificationGas","userOp","p","resolveProperties","calcPreVerificationGas","packUserOp","encodeUserOpCallDataAndGasLimit","detailsForUserOp","parseNumber","a","BigNumber","from","toString","value","_a","callData","encodeExecute","target","data","callGasLimit","_b","gasLimit","estimateGas","to","getUserOpHash","op","chainId","getNetwork","then","net","senderAddress","estimateCreationGas","deployerAddress","substring","deployerCallData","createUnsignedUserOp","info","initGas","verificationGasLimit","add","maxFeePerGas","maxPriorityFeePerGas","feeData","getFeeData","undefined","partialUserOp","nonce","getNonce","paymasterAndData","userOpForPm","Object","assign","preVerificationGas","getPaymasterAndData","signature","signUserOp","userOpHash","signUserOpHash","createSignedUserOp","getUserOpReceipt","timeout","arguments","interval","endtime","Date","now","events","queryFilter","filters","UserOperationEvent","transactionHash","Promise","resolve","setTimeout","exports"],"sources":["../../src/BaseAccountAPI.ts"],"sourcesContent":[null],"mappings":"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"},"metadata":{},"sourceType":"script","externalDependencies":[]}